"use strict";(self.webpackChunkrives_docs=self.webpackChunkrives_docs||[]).push([[8541],{1601:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>_,toc:()=>s});var i=n(4848),r=n(8453);const a={sidebar_position:6},o="Cheatsheet",_={id:"riv/cheatsheet",title:"Cheatsheet",description:"Functions",source:"@site/docs/riv/cheatsheet.md",sourceDirName:"riv",slug:"/riv/cheatsheet",permalink:"/docs/riv/cheatsheet",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Playing sounds",permalink:"/docs/riv/guides/playing-sounds"}},d={},s=[{value:"Functions",id:"functions",level:2},{value:"Basic",id:"basic",level:3},{value:"Resources",id:"resources",level:3},{value:"Drawing",id:"drawing",level:3},{value:"Audio",id:"audio",level:3},{value:"Pseudo random number generator",id:"pseudo-random-number-generator",level:3},{value:"Utilities",id:"utilities",level:3},{value:"RIV Context",id:"riv-context",level:2}];function l(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"cheatsheet",children:"Cheatsheet"}),"\n",(0,i.jsx)(e.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsxs)(e.p,{children:["The following is a reference of all functions provided by the RIV API in ",(0,i.jsx)(e.code,{children:"riv.h"})," header."]}),"\n",(0,i.jsx)(e.h3,{id:"basic",children:"Basic"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Present current frame, returns true until quit is requested.\nbool riv_present(void);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"resources",children:"Resources"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Load color palette from a PNG file\nuint32_t riv_load_palette(const char* filename, uint8_t start_col);\n// Load an image from a PNG file\nuint64_t riv_make_image(const char* filename, int64_t color_key);\n// Destroy an image\nvoid riv_destroy_image(uint64_t img_id);\n// Create an sprite sheet from an image\nuint64_t riv_make_spritesheet(uint64_t img_id, uint32_t w, uint32_t h);\n// Destroy an sprite sheet\nvoid riv_destroy_spritesheet(uint64_t sps_id);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"drawing",children:"Drawing"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Clear the screen\nvoid riv_clear(uint32_t col);\n// Draw a point\nvoid riv_draw_point(int64_t x, int64_t y, uint32_t col);\n// Draw a line determined by two points\nvoid riv_draw_line(int64_t x0, int64_t y0, int64_t x1, int64_t y1, uint32_t col);\n// Draw fill of a rectangle determined by its top left and size\nvoid riv_draw_rect_fill(int64_t x0, int64_t y0, int64_t w, int64_t h, uint32_t col);\n// Draw lines of a rectangle determined by its top left and size\nvoid riv_draw_rect_line(int64_t x0, int64_t y0, int64_t w, int64_t h, uint32_t col);\n// Draw fill of a quad determined by 4 points\nvoid riv_draw_quad_fill(int64_t x0, int64_t y0, int64_t x1, int64_t y1, int64_t x2, int64_t y2, int64_t x3, int64_t y3, uint32_t col);\n// Draw lines of a quad determined by 4 points\nvoid riv_draw_quad_line(int64_t x0, int64_t y0, int64_t x1, int64_t y1, int64_t x2, int64_t y2, int64_t x3, int64_t y3, uint32_t col);\n// Draw fill of a rotated rectangle determined by its center, size and angle\nvoid riv_draw_box_fill(int64_t ox, int64_t oy, int64_t w, int64_t h, float rot, uint32_t col);\n// Draw lines of a rotated rectangle determined by its center, size and angle\nvoid riv_draw_box_line(int64_t ox, int64_t oy, int64_t w, int64_t h, float rot, uint32_t col);\n// Draw fill of a circle determined by its center and size\nvoid riv_draw_circle_fill(int64_t ox, int64_t oy, int64_t d, uint32_t col);\n// Draw line of a circle determined by its center and size\nvoid riv_draw_circle_line(int64_t ox, int64_t oy, int64_t d, uint32_t col);\n// Draw fill of a ellipse determined by its center and size\nvoid riv_draw_ellipse_fill(int64_t ox, int64_t oy, int64_t w, int64_t h, uint32_t col);\n// Draw line of a ellipse determined by its center and size\nvoid riv_draw_ellipse_line(int64_t ox, int64_t oy, int64_t w, int64_t h, uint32_t col);\n// Draw fill of a triangle determined by 3 points\nvoid riv_draw_triangle_fill(int64_t x0, int64_t y0, int64_t x1, int64_t y1, int64_t x2, int64_t y2, uint32_t col);\n// Draw line of a triangle determined by 3 points\nvoid riv_draw_triangle_line(int64_t x0, int64_t y0, int64_t x1, int64_t y1, int64_t x2, int64_t y2, uint32_t col);\n// Draw fill of a rectangle copied from an image\nvoid riv_draw_image_rect(uint64_t img_id, int64_t x0, int64_t y0, int64_t w, int64_t h, int64_t sx0, int64_t sy0, int64_t mw, int64_t mh);\n// Draw fill of a rectangle copied from a sprite sheet\nvoid riv_draw_sprite(uint32_t n, uint64_t sps_id, int64_t x0, int64_t y0, int64_t nw, int64_t nh, int64_t mw, int64_t mh);\n// Draw text determined by its sprite sheet, anchor point, size and returns its size\nriv_vec2i riv_draw_text(const char* text, uint64_t sps_id, riv_align anchor, int64_t x, int64_t y, int64_t size, int64_t col);\n// Draw text determined by its sprite sheet, anchor point, size, scale, spacing and returns its size\nriv_vec2i riv_draw_text_ex(const char* text, uint64_t sps_id, riv_align anchor, int64_t x, int64_t y, int64_t mw, int64_t mh, int64_t sx, int64_t sy, int64_t col);\n\n"})}),"\n",(0,i.jsx)(e.h3,{id:"audio",children:"Audio"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Create a new sound buffer\nuint64_t riv_make_soundbuffer(riv_soundbuffer_desc* desc);\n// Destroy a sound buffer\nvoid riv_destroy_soundbuffer(uint64_t sndbuf_id);\n// Play a sound buffer or update a sound\nuint64_t riv_sound(riv_sound_desc* desc);\n// Play a waveform sound\nuint64_t riv_waveform(riv_waveform_desc* desc);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"pseudo-random-number-generator",children:"Pseudo random number generator"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Seed pseudo random number generator\nvoid riv_srand(uint64_t a, uint64_t b);\n// Return a random  uint64 in range [0, MAX_UINT64]\nuint64_t riv_rand(void);\n// Return a random  uint64 in range [0, high]\nuint64_t riv_rand_uint(uint64_t high);\n// Return a random   int64 in range [low, high]\nint64_t riv_rand_int(int64_t low, int64_t high);\n// Return a random float64 in range [0.0, 1.0)\ndouble riv_rand_float(void);\n"})}),"\n",(0,i.jsx)(e.h3,{id:"utilities",children:"Utilities"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Print to standard output, use for debugging only\nuint64_t riv_printf(const char* format, ...);\n// Format a string into a temporary buffer, the string remains valid until next frame\nchar *riv_tprintf(const char* format, ...);\n// Format a string\nuint64_t riv_snprintf(char* buf, uint64_t n, const char* format, ...);\n// Get the RIV version at runtime\nuint64_t riv_version(void);\n// Get the current machine cycle, THIS IS NON REPRODUCIBLE, use for bench-marking only\nuint64_t riv_rdcycle(void);\n"})}),"\n",(0,i.jsx)(e.h2,{id:"riv-context",children:"RIV Context"}),"\n",(0,i.jsxs)(e.p,{children:["The following is all fields available in the ",(0,i.jsx)(e.code,{children:"riv"})," context."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"////////////////////////////////////////////////////////////////////////////////\n// RIV context structure\n//\n// The RIV context is a 12MB structure mapped at the virtual memory address 0x10000000,\n// it contains all the public and private state used by other RIV APIs.\n// Some fields can be read/write directly as convenience.\n// Every field that can be read or written directly are marked as:\n// - [R] - Can be read at any moment\n// - [W] - Can be write at any moment\n// - [RW] - Can be read/write at any moment\n// Other fields without RW marks are used internally and should not be read or written.\n//\ntypedef struct riv_context {\n  //////////////////////////////////////\n  // MMIO driver (driver writes/device reads)\n  riv_mmio_header mmio_driver_header;       // MMIO driver header\n  uint64_t frame;                           // [R] Current frame number\n  uint32_t outcard_len;                     // [RW] Output card length\n  uint32_t statecard_len;                   // [RW] State card length\n  uint32_t height;                          // [RW] Screen height\n  uint32_t width;                           // [RW] Screen width\n  uint32_t target_fps;                      // [RW] Screen target refresh rate\n  riv_pixel_format pixel_format;            // [RW] Screen pixel format\n  uint32_t palette[RIV_MAX_COLORS];         // [RW] Color palette\n  bool tracked_keys[RIV_NUM_KEYCODE];       // [RW] Key codes being tracked\n  riv_command commands[RIV_MAX_COMMANDS];   // Command queue to be executed by the device\n  uint32_t command_len;                     // Command queue length\n  uint8_t mmio_driver_padding[780];         // Reserved\n\n  //////////////////////////////////////\n  // MMIO device (device writes/driver reads)\n  riv_mmio_header mmio_device_header;       // MMIO device header\n  uint32_t incard_len;                      // [R] Input card length\n  uint32_t initial_statecard_len;           // [R] Initial state card length\n  uint32_t key_toggle_count;                // [R] Number of toggled keys in this frame\n  uint8_t key_toggles[RIV_MAX_KEY_TOGGLES]; // [R] Toggled key in this frame (in order)\n  uint8_t mmio_device_padding[4004];        // Reserved\n\n  //////////////////////////////////////\n  // Public state\n  int64_t time_ms;                            // [R] Current time in milliseconds since first frame\n  double time;                                // [R] Current time in seconds since first frame\n  uint64_t quit_frame;                        // [RW] Stop main loop at the specified frame\n  bool quit;                                  // [RW] Whether to stop main loop after this frame\n  bool valid;                                 // [R] Whether we are initialized\n  bool verifying;                             // [R] Whether we are verifying\n  bool yielding;                              // [R] Whether every frame should yield audio/video\n  uint32_t key_modifiers;                     // [R] Current keyboard modifiers (e.g CTRL/ALT/SHIFT)\n  riv_key_state keys[RIV_NUM_KEYCODE];        // [R] Current keyboard state\n  riv_draw_state draw;                        // [RW] Draw state\n  riv_image images[RIV_MAX_IMAGES];           // [RW] Loaded images\n  riv_spritesheet spritesheets[RIV_MAX_SPRITESHEETS]; // [RW] Loaded sprite sheets\n  uint8_t pub_driver_padding[904360];         // Reserved\n\n  //////////////////////////////////////\n  // Internal state\n  riv_xoshiro256 prng;                        // PRNG state\n  uint64_t entropy[128];                      // Entropy accumulated from inputs\n  uint32_t entropy_index;                     // Entropy index\n  uint32_t entropy_size;                      // Entropy size\n  uint64_t sound_gen;                         // Counter for generating sound ids\n  uint64_t soundbuffer_gen;                   // Counter for generating sound buffer ids\n  uint64_t image_gen;                         // Counter for generating image ids\n  uint64_t sprite_gen;                        // Counter for generating sprite ids\n  uint32_t txbuffer_off;                      // Current transfer buffer offset\n  uint32_t verify_key_event_index;            // Current event index when verifying\n  riv_key_toggle_event *verify_key_events;    // List of events to follow when verifying\n  uint64_t stop_frame;                        // Device requested stop frame\n  uint64_t temp_str_off;                      // Temporary string buffer offset\n  uint8_t temp_str_buf[RIV_SIZE_TEMP_STRBUF]; // Temporary string buffer (used by riv_tprintf)\n  uint8_t prv_driver_padding[981912];         // Reserved\n\n  //////////////////////////////////////\n  // Buffers\n  uint8_t incard[RIV_SIZE_INCARD];                    // [R] Input card buffer\n  uint8_t outcard[RIV_SIZE_OUTCARD];                  // [RW] Output card buffer\n  uint8_t statecard[RIV_SIZE_STATECARD];              // [RW] State card buffer\n  uint8_t framebuffer[RIV_SIZE_FRAMEBUFFER];          // [RW] Screen frame buffer\n  uint8_t txbuffer[RIV_SIZE_TXBUFFER];                // Data buffer for device commands\n} riv_context;\n"})})]})}function u(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(l,{...t})}):l(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>o,x:()=>_});var i=n(6540);const r={},a=i.createContext(r);function o(t){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function _(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(r):t.components||r:o(t.components),i.createElement(a.Provider,{value:e},t.children)}}}]);