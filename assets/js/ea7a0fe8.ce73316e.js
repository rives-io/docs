"use strict";(self.webpackChunkrives_docs=self.webpackChunkrives_docs||[]).push([[9116],{3871:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>c});var s=i(4848),r=i(8453);const t={sidebar_position:3},o="Developing cartridges",a={id:"riv/developing-cartridges",title:"Developing cartridges",description:"This tutorial will guide on how to setup your",source:"@site/docs/riv/developing-cartridges.md",sourceDirName:"riv",slug:"/riv/developing-cartridges",permalink:"/docs/riv/developing-cartridges",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Getting started",permalink:"/docs/riv/getting-started"},next:{title:"Creating a game",permalink:"/docs/riv/creating-a-game"}},l={},c=[{value:"Creating your first application in C",id:"creating-your-first-application-in-c",level:2},{value:"Interactive terminal with workspaces",id:"interactive-terminal-with-workspaces",level:2},{value:"Installing the RIV SDK",id:"installing-the-riv-sdk",level:2},{value:"Creating your first cartridge",id:"creating-your-first-cartridge",level:2},{value:"Testing cartridges in a web browser",id:"testing-cartridges-in-a-web-browser",level:2},{value:"Compiling cartridges",id:"compiling-cartridges",level:2},{value:"Compiling optimized cartridges",id:"compiling-optimized-cartridges",level:2},{value:"Debugging cartridges",id:"debugging-cartridges",level:2},{value:"Inspecting cartridges",id:"inspecting-cartridges",level:2},{value:"Benchmarking cartridges",id:"benchmarking-cartridges",level:2},{value:"Customizing SDK to install new tools",id:"customizing-sdk-to-install-new-tools",level:2},{value:"Using other programming languages",id:"using-other-programming-languages",level:2},{value:"Using scripting languages",id:"using-scripting-languages",level:2},{value:"Porting other games",id:"porting-other-games",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"developing-cartridges",children:"Developing cartridges"})}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will guide on how to setup your\ndevelopment workflow and how to create your first cartridge."}),"\n",(0,s.jsx)(n.p,{children:"By the end of this tutorial you will know how to create cartridge files,\ncompile cartridges, debug cartridges, benchmark cartridges,\ninspect cartridges and how to use other programming languages to create cartridges."}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will begin quickly by running your first graphical application,\nand then expand slowly about all the tools RIV SDK offers to develop cartridges,\nyou will learn some new interesting RIVEMU options on the go."}),"\n",(0,s.jsxs)(n.p,{children:["If you have not installed RIVEMU yet, please read\nthe ",(0,s.jsx)(n.a,{href:"getting-started",children:"getting started page"})," first."]}),"\n",(0,s.jsx)(n.h2,{id:"creating-your-first-application-in-c",children:"Creating your first application in C"}),"\n",(0,s.jsxs)(n.p,{children:["Technically you can use any programming supported by Linux RISC-V to create cartridges,\nhowever RIV offers its standard API in C with ",(0,s.jsx)(n.code,{children:"libriv"}),",\ntherefore you can use C to create RIV cartridges.\nThis tutorial will focus on using just C to getting started and understand the basics,\nlater it will expand on how to use other programming languages."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's begin creating a file named ",(0,s.jsx)(n.code,{children:"hello.c"})," with the following contents:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <riv.h>\n\nint main() {\n    do {\n        // clear screen\n        riv_clear(RIV_COLOR_BLACK);\n        // draw hello world\n        riv_draw_text("hello world!", RIV_SPRITESHEET_FONT_5X7, RIV_CENTER, 128, 128, 2, RIV_COLOR_WHITE);\n    } while(riv_present());\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The standard RIV OS comes with a JIT for C programming language called ",(0,s.jsx)(n.code,{children:"riv-jit-c"}),",\nso you can run this example directly without having to actually compile it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -workspace -exec riv-jit-c hello.c\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should see a screen popup, and that is it, your first hello world program running in RIV!"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"-exec"})," option overrides the standard machine entrypoint to execute a custom command,\nin this case we are executing ",(0,s.jsx)(n.code,{children:"riv-jit-c"})," to run the ",(0,s.jsx)(n.code,{children:"hello.c"})," file.\nThe ",(0,s.jsx)(n.code,{children:"-workspace"})," option exposes current directory files into the machine,\nit will be explained in detail in the next section."]}),"\n",(0,s.jsxs)(n.p,{children:["The C code presented so far should be self explanatory,\nwe have a line that clear the screen,\nanother to draw a text and finally a line to present the cartridge frame.\nYou can read the full ",(0,s.jsx)(n.em,{children:"libriv"})," C API in its\nheader at ",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/libriv/riv.h",children:"riv.h"}),",\nfor now we won't give much details on its functions,\nlet's continue understanding the RIV development workflow first."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/hello-c.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"interactive-terminal-with-workspaces",children:"Interactive terminal with workspaces"}),"\n",(0,s.jsxs)(n.p,{children:["Notice in the last example the ",(0,s.jsx)(n.code,{children:"-workspace"})," option,\nit mounts the current working directory from your host to the ",(0,s.jsx)(n.code,{children:"/workspace"})," directory in the RIV machine,\nto make development easier."]}),"\n",(0,s.jsxs)(n.p,{children:["This is a good time show how RIV is also a Linux,\nwhere you can work in its own terminal when combining with the ",(0,s.jsx)(n.code,{children:"-it"})," option:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -workspace -it\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"-it"})," options standards for interactive terminal,\nit gives the ability to type commands inside a terminal running inside a running RIV machine.\nYou can type really almost any Linux command, for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"rivos:/workspace# uname -mns\nLinux rivos riscv64\nrivos:/workspace# pwd\n/workspace\nrivos:/workspace# ls *.c\nhello.c\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice the ",(0,s.jsx)(n.code,{children:"hello.c"})," from last example is there,\nbecause ",(0,s.jsx)(n.code,{children:"-workspace"})," mounted the current working directory,\nwhile we are inside a RISC-V 64-bit Linux machine."]}),"\n",(0,s.jsxs)(n.p,{children:["You can also run your ",(0,s.jsx)(n.code,{children:"hello.c"})," directly from the shell inside riv:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"riv-jit-c hello.c\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you edit the file ",(0,s.jsx)(n.code,{children:"hello.c"})," in a file editor in your host,\nthe changes will also take effect inside RIV OS.\nBut why would you want to run commands inside the RIV OS terminal?\nWell because the RIV also has the RIV SDK that comes with lot of utilities\nfor developing cartridges,\ntools for compiling RISC-V binaries, compressing files into cartridge archives,\nand debuggers for debugging RISC-V applications."]}),"\n",(0,s.jsx)(n.p,{children:"After you experiment with it, make sure to exit the interactive terminal session\nto continue to the next section."}),"\n",(0,s.jsx)(n.h2,{id:"installing-the-riv-sdk",children:"Installing the RIV SDK"}),"\n",(0,s.jsx)(n.p,{children:"RIVEMU comes with a builtin and minimal operating system called RIV OS,\nthis RIV OS contains the bare minimal libraries and utilities\nto run cartridges, but in order to actually create cartridges\nyou need many more tools like programming language compilers\nand archive compressors."}),"\n",(0,s.jsx)(n.p,{children:"You may also want to customize the RIV SDK with your own Linux tools,\nsuch as other programming languages (e.g Rust, Zig, Nim..).\nWith the SDK you can do this, because it's writable and customizable,\nwhile the builtin standard minimal RIV OS is read-only."}),"\n",(0,s.jsx)(n.p,{children:"Bear in mind the standard SDK is very large (about 500MB),\nbecause it contains compilers, debuggers, editors, and many other tools for development only."}),"\n",(0,s.jsx)(n.p,{children:"Let's download the SDK and try it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"wget -O rivos-sdk.ext2 https://github.com/rives-io/riv/releases/latest/download/rivos-sdk.ext2\nrivemu -sdk=rivos-sdk.ext2 -exec gcc --version\n"})}),"\n",(0,s.jsx)(n.p,{children:"You probably got an output that contains something like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"gcc (Alpine 13.2.1_git20240309) 13.2.1 20240309\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"-sdk=rivos-sdk.ext2"})," overrides the standard operating system\nto use the SDK operating system,\nthe command ",(0,s.jsx)(n.code,{children:"-exec gcc --version"})," should show the GCC C compiler version\nthat is included in the SDK, which was not included in the minimal RIV OS."]}),"\n",(0,s.jsx)(n.p,{children:"Lets now install this SDK globally, to make available in any terminal in your system:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"mkdir -p $HOME/.riv/\nmv rivos-sdk.ext2 $HOME/.riv/\necho 'export RIVEMU_SDK=$HOME/.riv/rivos-sdk.ext2' >> $HOME/.bashrc\nexport RIVEMU_SDK=$HOME/.riv/rivos-sdk.ext2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When setting the environment ",(0,s.jsx)(n.code,{children:"RIVEMU_SDK"}),",\nRIVEMU will be able to auto detect and load the SDK,\nso you can use from anywhere in your system,\nlet's try it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -exec /usr/lib/libriv.so version\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should see and output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"0.3.0\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We have introduced new command line options here.\nThe ",(0,s.jsx)(n.code,{children:"-quiet"})," makes RIVEMU less verbose because we just\nwant to see an output from a command executed inside the machine.\nThe ",(0,s.jsx)(n.code,{children:"-no-window"})," makes RIVEMU never create a graphical window,\nbecause we want to just run a console application in this case, that is, we won't be playing a cartridge.\nThe ",(0,s.jsx)(n.code,{children:"-sdk"})," without a filename will try to read the SDK filesystem from ",(0,s.jsx)(n.code,{children:"RIVEMU_SDK"})," environment variable.\nThe ",(0,s.jsx)(n.code,{children:"-exec /usr/lib/libriv.so version"})," will execute a command to check the ",(0,s.jsx)(n.code,{children:"libriv"})," version in the OS."]}),"\n",(0,s.jsx)(n.h2,{id:"creating-your-first-cartridge",children:"Creating your first cartridge"}),"\n",(0,s.jsxs)(n.p,{children:["Now with the SDK installed,\nlet's get back to the ",(0,s.jsx)(n.code,{children:"hello.c"})," example and actually turn it into a cartridge."]}),"\n",(0,s.jsxs)(n.p,{children:["Every cartridge must have an ",(0,s.jsx)(n.em,{children:"entrypoint"})," to actually run,\nfirst let create a shell script file named ",(0,s.jsx)(n.code,{children:"0-entry.sh"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'echo "riv-jit-c hello.c" > 0-entry.sh\nchmod +x 0-entry.sh\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Why the name is ",(0,s.jsx)(n.code,{children:"0-entry.sh"}),"? When running a cartridge,\nRIV actually executes the first executable file in a cartridge,\nsorted alphabetically.\nIn case you have other executable binaries in your cartridge,\nthey could executed before the entrypoint as a mistake,\nso it is recommended to make the entrypoint be the first file\nwhen ordering its files by name."]}),"\n",(0,s.jsxs)(n.p,{children:["Now lets invoke RIVEMU to actually compress both ",(0,s.jsx)(n.code,{children:"0-entry.sh"})," and ",(0,s.jsx)(n.code,{children:"hello.c"})," into\na cartridge archive."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -workspace -exec riv-mksqfs 0-entry.sh hello.c hello.sqfs\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"riv-mksqfs"})," command should create the actual cartridge ",(0,s.jsx)(n.code,{children:".sqfs"})," file, lets inspect it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -workspace -exec 'ls -l hello.sqfs && file hello.sqfs'\n"})}),"\n",(0,s.jsx)(n.p,{children:"It should output something similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"-rw-r--r--    1 user     user          4096 Apr 19 20:48 hello.sqfs\nhello.sqfs: Squashfs filesystem, little endian, version 4.0, zlib compressed, 434 bytes, 3 inodes, blocksize: 131072 bytes, created: Thu Jan  1 00:00:00 1970\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can see the cartridge file has 4096 bytes,\nthis is because cartridges actually are SquashFS compressed filesystem,\nwhich are always saved in multiple of 4KB,\nthis also means the minimum size for a cartridge is always 4KB.\nNotice the cartridge contents were compressed with ",(0,s.jsx)(n.em,{children:"zlib"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The compression could also be tuned to generate smaller cartridges,\nfor example you could use more aggressive compression appending ",(0,s.jsx)(n.code,{children:"-comp xz"}),",\nlike ",(0,s.jsx)(n.code,{children:"riv-mksqfs 0-entry.sh hello.c hello.sqfs -comp xz"}),"\nfor checking available compressions read ",(0,s.jsx)(n.code,{children:"mksquashfs -help"})]}),"\n",(0,s.jsx)(n.p,{children:"Now lets finally run it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu hello.sqfs\n"})}),"\n",(0,s.jsx)(n.p,{children:'If everything worked, you should see "hello world!" screen show up.\nThis is your first cartridge!'}),"\n",(0,s.jsx)(n.p,{children:"This cartridge file is also the one you should upload on RIVES."}),"\n",(0,s.jsx)(n.h2,{id:"testing-cartridges-in-a-web-browser",children:"Testing cartridges in a web browser"}),"\n",(0,s.jsxs)(n.p,{children:["Having a cartridge running locally in the RIVEMU is great,\nbut most players will probably play your cartridges in a Web Browser,\nluckily RIVEMU was also ported to WebAssembly,\nRIV has a test page for you to test a cartridge in the browser\nat the ",(0,s.jsx)(n.a,{href:"https://emulator.rives.io",children:"emulator testing page"}),'.\nGo there and search for the "Upload" button in the "Cartridge" section,\nuse it to upload your ',(0,s.jsx)(n.code,{children:"hello.sqfs"}),"."]}),"\n",(0,s.jsx)(n.p,{children:'If everything works fine, you should be able to see the "hello world!"\nin the browser.\nEvery time you finish developing a cartridge,\nit\'s recommended to actually test it in the browser,\nbecause the performance can be different than running natively,\nusually performance drops by 20% or more.'}),"\n",(0,s.jsxs)(n.p,{children:["Also in the browser you can even use game pads to test your game!\nIf you have a PS4, Xbox or Nintendo Switch controller,\njust plug in your computer and most browser supports them through\nthe HTML5 Gamepad API specification.\nBefore trying this, you should check if your game pad is working in your browser\nin third party services such as\n",(0,s.jsx)(n.a,{href:"https://hardwaretester.com/gamepad",children:"this game pad tester"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"compiling-cartridges",children:"Compiling cartridges"}),"\n",(0,s.jsxs)(n.p,{children:["In our first cartridge ",(0,s.jsx)(n.code,{children:"hello.sqfs"}),", we used ",(0,s.jsx)(n.code,{children:"riv-jit-c"})," to run ",(0,s.jsx)(n.code,{children:"hello.c"}),",\nalthough this was very easy we can actually compile it into a ",(0,s.jsx)(n.code,{children:"hello"})," RISC-V executable binary:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -workspace -exec gcc hello.c -o hello -lriv\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The command ",(0,s.jsx)(n.code,{children:"gcc hello.c -o hello -lriv"})," compiles ",(0,s.jsx)(n.code,{children:"hello.c"}),"\nsource code into ",(0,s.jsx)(n.code,{children:"hello"})," Linux RISC-V ELF binary linked to ",(0,s.jsx)(n.code,{children:"libriv"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Before generating a cartridge for it, let's test it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -workspace -exec ./hello\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then you should see a hello world screen like before.\nNow let's actually compile a cartridge and run it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -workspace -exec riv-mksqfs hello hello-compiled.sqfs\nrivemu hello-compiled.sqfs\n"})}),"\n",(0,s.jsx)(n.p,{children:"Like before you should see hello world screen,\nbut this cartridge is different from the first one,\nbecause it used ahead of time compilation now,\nwhich makes your cartridge faster to load and run and smaller for cartridges with lot of code.\nWe recommend to use JIT just for prototyping,\nwhen possible your final release cartridge should be statically compiled."}),"\n",(0,s.jsx)(n.h2,{id:"compiling-optimized-cartridges",children:"Compiling optimized cartridges"}),"\n",(0,s.jsxs)(n.p,{children:["In last example we compiled a C code, but we did not enable any optimization,\nlets enable them not only for improve its performance, but also to reduce its final size,\nso we can make a cartridge smaller.\nRIV SDK comes with a tool to assist you choosing C compilers flags to\nto generate optimized and small binaries called ",(0,s.jsx)(n.code,{children:"riv-opt-flags"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Lets recompile a new cartridge for the last example again using these tools:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"alias rivemu-exec='rivemu -quiet -no-window -sdk -workspace -exec'\nrivemu-exec 'gcc hello.c -o hello-optimized $(riv-opt-flags -Ospeed)'\nrivemu-exec riv-strip hello-optimized\nrivemu-exec riv-mksqfs hello-optimized hello-optimized.sqfs\nrivemu hello-optimized.sqfs\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's break what happened:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["In the first line we create the alias ",(0,s.jsx)(n.code,{children:"rivemu-exec"}),", a shortcut to invoke commands inside RIV OS."]}),"\n",(0,s.jsxs)(n.li,{children:["In the second line we compile ",(0,s.jsx)(n.code,{children:"hello.c"})," again, but this time to ",(0,s.jsx)(n.code,{children:"hello-optimized"})," using compiler flags from ",(0,s.jsx)(n.code,{children:"riv-opt-flags -Ospeed"}),", this will supply compiler flags to optimized for speed because we passed ",(0,s.jsx)(n.code,{children:"-Ospeed"}),", this tool also accepts ",(0,s.jsx)(n.code,{children:"-Osize"})," to optimize for size, and ",(0,s.jsx)(n.code,{children:"-Odebug"})," to optimize for debugging."]}),"\n",(0,s.jsxs)(n.li,{children:["In the third line we strip unwanted data from the ELF binary ",(0,s.jsx)(n.code,{children:"hello-optimized"}),", this should compress the file a little more."]}),"\n",(0,s.jsxs)(n.li,{children:["In the fourth line we create the cartridge ",(0,s.jsx)(n.code,{children:"hello-optimized.sqfs"})]}),"\n",(0,s.jsx)(n.li,{children:"Finally in the last line we test it."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Lets compare the final with old one we created:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ rivemu-exec 'unsquashfs -stat hello-compiled.sqfs | grep bytes'\nFilesystem size 3517 bytes (3.43 Kbytes / 0.00 Mbytes)\n$ rivemu-exec 'unsquashfs -stat hello-optimized.sqfs | grep bytes'\nFilesystem size 1661 bytes (1.62 Kbytes / 0.00 Mbytes)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice the data in ",(0,s.jsx)(n.code,{children:"hello-optimized.sqfs"})," cartridge is smaller than ",(0,s.jsx)(n.code,{children:"hello-compiled.sqfs"}),".\nHowever if you take a look with ",(0,s.jsx)(n.code,{children:"ls -la"}),", you will notice both cartridges files are still at 4KB,\nthis is because SquashFS files add 0 padding at the end, to make us able to use the ",(0,s.jsx)(n.code,{children:"mount"})," command.\nThis cartridge is very small, only in a more complex one you would see the benefits."]}),"\n",(0,s.jsxs)(n.p,{children:["If you can afford, prefer to use ",(0,s.jsx)(n.code,{children:"-Ospeed"})," to optimize for performance,\nuse ",(0,s.jsx)(n.code,{children:"-Osize"})," only if you really want to reduce its size as priority,\nand use ",(0,s.jsx)(n.code,{children:"-Odebug"})," only to debug while in development."]}),"\n",(0,s.jsx)(n.p,{children:"On RIVES it is recommended to upload optimized and small cartridges to reduce costs,\nand improve its verification performance.\nEven though both are 4KB, the ones containing zeros will cost less to upload on RIVES,\nbecause transactions with zeros in them cost less in some blockchain base layers."}),"\n",(0,s.jsx)(n.h2,{id:"debugging-cartridges",children:"Debugging cartridges"}),"\n",(0,s.jsxs)(n.p,{children:["In the last example we mentioned ",(0,s.jsx)(n.code,{children:"-Odebug"})," to optimize for debugging,\nbut how can you debug? Well you can just use the GDB debugger."]}),"\n",(0,s.jsxs)(n.p,{children:["Lets compile again our minimal ",(0,s.jsx)(n.code,{children:"hello.c"})," program and debug it with GDB:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -workspace -exec 'gcc hello.c -o hello-debug $(riv-opt-flags -Odebug)'\nrivemu -quiet -sdk -workspace -it -exec gdb -silent ./hello-debug\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This should open ",(0,s.jsx)(n.code,{children:"gdb"})," session so you can debug the cartridge,\nhere is a copy of a session demonstrating how to step over each function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'$ rivemu -quiet -sdk -workspace -it -exec gdb -silent ./hello-debug\nReading symbols from ./hello-debug...\n(gdb) break main\nBreakpoint 1 at 0x8b0: file hello.c, line 6.\n(gdb) run\nStarting program: /workspace/hello-debug\n\nBreakpoint 1.1, main () at hello.c:6\n6           riv_clear(RIV_COLOR_BLACK);\n(gdb) step\n8           riv_draw_text("hello world!", RIV_SPRITESHEET_FONT_5X7, RIV_CENTER, 128, 128, 2, RIV_COLOR_WHITE);\n(gdb) step\n9       } while(riv_present());\n(gdb) step\n\nBreakpoint 1.1, main () at hello.c:6\n8           riv_clear(RIV_COLOR_BLACK);\n(gdb) p riv.frame\n$1 = 1\n'})}),"\n",(0,s.jsx)(n.p,{children:"Notice in this session we break at the program startup, and then run each line by line.\nAt the end we print which frame we are with.\nIn the end, you can debug cartridges normally as debugging C programs."}),"\n",(0,s.jsxs)(n.p,{children:["If you debug a cartridge with a ",(0,s.jsx)(n.em,{children:"tape"}),",\nyou could inspect the game frame by frame.\nSounds useful for debugging nasty bugs while developing a game right?\nFor example, imagine a player found a bug in your game,\nyou could just ask him to record a tape of the bug,\nthen you can use it to debug frame by frame."]}),"\n",(0,s.jsx)(n.h2,{id:"inspecting-cartridges",children:"Inspecting cartridges"}),"\n",(0,s.jsxs)(n.p,{children:["What if you got a cartridge from someone and would like to inspect it?\nYou can use RIVEMU in interactive mode for that.\nLets inspect the ",(0,s.jsx)(n.code,{children:"antcopter.sqfs"})," cartridge\nthat was previously downloaded in the getting started page:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:'$ rivemu -quiet -sdk -workspace -it\nrivos-sdk:/workspace# mount antcopter.sqfs /cartridge\nrivos-sdk:/workspace# cd /cartridge\nrivos:/cartridge# ls -l\ntotal 43\n-rwxr-xr-x    1 root     root         42632 Jan  1  1970 antcopter\n-rw-r--r--    1 root     root          1006 Jan  1  1970 info.json\nrivos:/cartridge# file antcopter\nantcopter: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-riscv64.so.1, no section header\nrivos:/cartridge# jq < info.json\n{\n  "name": "Antcopter",\n  "summary": "A 2D speed run platform game where you are a little ant that can glide in the air",\n...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The text above is a copy of an interactive session inspecting ",(0,s.jsx)(n.code,{children:"antcopter.sqfs"}),".\nYou can see it has only 2 files, yhe ",(0,s.jsx)(n.code,{children:"antcopter"})," RISC-V binary that contains the game,\nand ",(0,s.jsx)(n.code,{children:"info.json"})," JSON file that contains some metadata,\nthis metadata is used on RIVES to create a catalog of games,\ncartridges are recommended to have this metadata included to distribute them on RIVES."]}),"\n",(0,s.jsxs)(n.p,{children:["Go ahead and run ",(0,s.jsx)(n.code,{children:"/cartridge/antcopter"})," command in the interactive terminal,\nyou should be able to play it."]}),"\n",(0,s.jsx)(n.h2,{id:"benchmarking-cartridges",children:"Benchmarking cartridges"}),"\n",(0,s.jsx)(n.p,{children:"It's a good practice to measure the performance of your cartridge before distributing it,\nfor two reasons.\nOne because you have a quota limit on how much computation a cartridge tape can process,\nand also because you want your cartridges execution to be lightweight enough\nto run with acceptable performance on different systems the emulator is running on."}),"\n",(0,s.jsxs)(n.p,{children:["RIVEMU has the command ",(0,s.jsx)(n.code,{children:"-bench"})," to help benchmarking your cartridge,\nit's recommended to benchmark only your final cartridge ",(0,s.jsx)(n.code,{children:".sqfs"})," file,\nlets benchmark ",(0,s.jsx)(n.code,{children:"hello-optimized.sqfs"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -bench hello-optimized.sqfs\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should get an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[RIVEMU] frame=1 fps=0.97 cpu_cost=4190.38MIPS cpu_speed=372.25MIPS cpu_usage=18.15% cpu_quota=0.07%\n[RIVEMU] frame=16 fps=59.99 cpu_cost=2.30MIPS cpu_speed=412.79MIPS cpu_usage=0.56% cpu_quota=0.07%\n[RIVEMU] frame=31 fps=59.99 cpu_cost=2.31MIPS cpu_speed=384.98MIPS cpu_usage=0.60% cpu_quota=0.07%\n[RIVEMU] frame=46 fps=59.97 cpu_cost=2.32MIPS cpu_speed=407.28MIPS cpu_usage=0.57% cpu_quota=0.07%\n[RIVEMU] frame=62 fps=59.99 cpu_cost=2.30MIPS cpu_speed=420.51MIPS cpu_usage=0.55% cpu_quota=0.08%\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's break down this information:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"frame"}),": it's the frame processed so far,\ncartridges by default usually process 60 frames per second, but this can be customized."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fps"}),": it's how much frames per second your computer is capable of processing,\nusually we want this number to be close to 60."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cpu_cost"}),": it's how much CPU instructions costed to process exactly 1 second of computation,\nit's measured in MIPS (million instructions per second),\nusually we want this number to be low and below ",(0,s.jsx)(n.code,{children:"cpu_speed"}),",\nhigh values means the cartridge is sub optimized,\ncartridges must try to keep this value below 128MIPS when running to allow everyone to run it smoothly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cpu_speed"}),": it's how much CPU instruction per second your computer is capable of emulating,\nthis value may vary on the system you are running,\nRIV is designed to run on system that is at least capable of running 128MIPS,\nsystems that are not able to emulate at that speed may experience stuttering when playing heavy cartridges."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cpu_usage"}),": it's how much of the CPU the cartridge is using,\nif this value is above 90%, you may experience stuttering when playing the cartridge."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cpu_quota"}),": it's how much CPU computation quota has been processed so far,\nRIV hardware spec set the quota to be 96 billion CPU instructions,\nwhen CPU quota reaches 100%, the game halts immediately."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you look closely the first frame always costs more MIPS,\nbecause the machine has to boot and load the game.\nAfter the first frame the CPU quota keeps increasing slowly,\nit will increase indefinitely until the game ends.\nThe FPS should remain stable most of the time.\nThe CPU speed may vary a lot, because different instructions has different speeds,\nand also because your system may be busy processing other programs.\nThe CPU cost should remain stable for well designed cartridges,\ncartridges that increase CPU cost at random frames may experience\nstuttering, degrading game play quality."}),"\n",(0,s.jsx)(n.p,{children:"This RIVEMU web page can also show all this information when testing a cartridge."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"hello-optimized.sqfs"})," is not doing much, if you play a heavy cartridge,\nlike DOOM, you will see numbers similar to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[RIVEMU] frame=1 fps=0.18 cpu_cost=12404.20MIPS cpu_speed=567.54MIPS cpu_usage=11.20% cpu_quota=0.37%\n[RIVEMU] frame=10 fps=33.75 cpu_cost=55.21MIPS cpu_speed=619.72MIPS cpu_usage=8.59% cpu_quota=0.38%\n[RIVEMU] frame=19 fps=35.99 cpu_cost=56.00MIPS cpu_speed=630.41MIPS cpu_usage=9.13% cpu_quota=0.40%\n[RIVEMU] frame=28 fps=33.76 cpu_cost=56.01MIPS cpu_speed=622.77MIPS cpu_usage=8.68% cpu_quota=0.41%\n"})}),"\n",(0,s.jsx)(n.p,{children:"So DOOM costs about 56MIPS, still way below the recommended max amount of 128MIPS,\nmost cartridges processing probably will not cost more CPU than that."}),"\n",(0,s.jsx)(n.h2,{id:"customizing-sdk-to-install-new-tools",children:"Customizing SDK to install new tools"}),"\n",(0,s.jsx)(n.p,{children:"You have learned so far how to\ncreate cartridges, compile them, compress them, inspect them, debug them and finally benchmark them.\nAll of this you did using tools we already provide in the SDK,\nhowever you can also add your own tools and programming languages to the SDK,\nwhile you could use them from outside, using from inside the RIVEMU RISC-V machine\nyou know the tool will work correctly for RISC-V."}),"\n",(0,s.jsx)(n.p,{children:"Lets download the Nim programming language, and in the section below we will use it to compile a cartridge."}),"\n",(0,s.jsx)(n.p,{children:"First let's get into a RIVEMU shell with networking support:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -sdk -workspace -net -persist -it\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice the added ",(0,s.jsx)(n.code,{children:"-net"})," here, this enables networking so you can install packages from the internet.\nNotice we also added the ",(0,s.jsx)(n.code,{children:"-persist"})," option,\nthis will make changes to the SDK persist, even when you exit the machine.\nUp until now any changes made in the filesystem were being\ndiscarded after the emulator quits."]}),"\n",(0,s.jsxs)(n.p,{children:["Inside a RIV SDK interactive terminal with networking, run ",(0,s.jsx)(n.code,{children:"apk add nim"})," to install Nim compiler,\nit will download and install Nim package from Alpine Linux package manager,\nand then test it with ",(0,s.jsx)(n.code,{children:"nim -v"}),", here is the session output:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell_session",children:"$ rivemu -quiet -sdk -workspace -net -persist -it\nrivos-sdk:/workspace# apk add nim\nfetch https://dl-cdn.alpinelinux.org/alpine/edge/main/riscv64/APKINDEX.tar.gz\nfetch https://dl-cdn.alpinelinux.org/alpine/edge/community/riscv64/APKINDEX.tar.gz\nfetch https://dl-cdn.alpinelinux.org/alpine/edge/testing/riscv64/APKINDEX.tar.gz\n(1/3) Installing libucontext (1.2-r3)\n(2/3) Installing libucontext-dev (1.2-r3)\n(3/3) Installing nim (2.0.2-r0)\nExecuting busybox-1.36.1-r25.trigger\nOK: 321 MiB in 93 packages\nrivos-sdk:/workspace# nim -v\nNim Compiler Version 2.0.2 [Linux: riscv64]\nCompiled at 2024-04-03\nCopyright (c) 2006-2023 by Andreas Rumpf\n\nactive boot switches: -d:release\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can also customize your own set of tools in the SDK.\nBeware that using ",(0,s.jsx)(n.code,{children:"-persist"})," you are modifying the original SDK,\nif you want to rollback the stock defaults, just download ",(0,s.jsx)(n.code,{children:"rivos-sdk.ext2"})," again."]}),"\n",(0,s.jsx)(n.p,{children:"But did the changes really persist? Let's check:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"$ rivemu -quiet -no-window -sdk -exec nim -v\nNim Compiler Version 2.0.2 [Linux: riscv64]\nCompiled at 2024-04-03\nCopyright (c) 2006-2023 by Andreas Rumpf\n\nactive boot switches: -d:release\n"})}),"\n",(0,s.jsx)(n.p,{children:"Yes, it's there, Nim compiler is now part of our customized SDK."}),"\n",(0,s.jsx)(n.p,{children:"As you install new stuff to the SDK, its disk will grow\nand eventually you might be out of disk space.\nTo fix this, you can increase the size of SDK disk with the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'rivemu -quiet -no-window -sdk -workspace="$(dirname $RIVEMU_SDK)" -exec resize2fs -f rivos-sdk.ext2 1024M\n'})}),"\n",(0,s.jsx)(n.p,{children:"This will set the SDK disk size to 1024M, which should double from its default size."}),"\n",(0,s.jsx)(n.h2,{id:"using-other-programming-languages",children:"Using other programming languages"}),"\n",(0,s.jsx)(n.p,{children:"We can use any programming language to make cartridges,\nas long it compiles to a self contained RISC-V ELF binary,\nor its cartridge brings together all dependencies it needs."}),"\n",(0,s.jsx)(n.p,{children:"In last section we installed Nim,\nwe could have installed any other programming as well.\nSince our customized SDK already have Nim,\nlet's show how you can use Nim to create cartridges,\neven though there is no official support for Nim in RIV."}),"\n",(0,s.jsxs)(n.p,{children:["Lets just port our hello example, create this file ",(0,s.jsx)(n.code,{children:"hello.nim"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-nim",children:'proc riv_present(): bool {.importc, header: "<riv.h>".}\nproc riv_clear(col: uint32): void {.importc, header: "<riv.h>".}\nproc riv_draw_text(text: cstring, sps_id: uint64, anchor: uint32, x: int64, y: int64, size: int64, col: int64): void {.importc, header: "<riv.h>".}\nconst\n    RIV_COLOR_BLACK: uint32 = 0\n    RIV_COLOR_WHITE: uint32 = 1\n    RIV_CENTER: uint32 = 4\n    RIV_SPRITESHEET_FONT_5X7: uint64 = 4095\n\nwhile true:\n    # clear screen\n    riv_clear(ord(RIV_COLOR_BLACK))\n    # draw hello world\n    riv_draw_text("hello world!", ord(RIV_SPRITESHEET_FONT_5X7), ord(RIV_CENTER), 128, 128, 2, ord(RIV_COLOR_WHITE))\n    if not riv_present():\n        break\n'})}),"\n",(0,s.jsx)(n.p,{children:"Did you notice this code looks similar to Python?\nThat is because Nim syntax is inspired by Python syntax,\nbut don't be fooled, this is a statically compiled programming language."}),"\n",(0,s.jsx)(n.p,{children:"Let's compile this file with Nim compiler using our customized SDK, and run it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu -quiet -no-window -sdk -workspace -exec nim compile --opt:size --mm:none -d:release --passL:-lriv --out:hello-nim hello.nim\nrivemu -workspace -exec ./hello-nim\n"})}),"\n",(0,s.jsx)(n.p,{children:'You should see a screen with "hello world!" again, but this time the original source code was made in Nim.'}),"\n",(0,s.jsx)(n.p,{children:"We could have installed other system programming languages, such as\nRust, Zig and Nelua.\nThese are the ones recommended because they are compiled.\nYou can also use scripting programming languages, which will be covered in the next section."}),"\n",(0,s.jsxs)(n.p,{children:["By the way, the official SDK come for compilers for C, C++ and Nelua.\nNelua even already has bindings for all ",(0,s.jsx)(n.code,{children:"riv.h"})," from ",(0,s.jsx)(n.code,{children:"libriv"})," in the SDK.\nThe RIV minimal OS also comes with Lua 5.4 interpreter and a JIT for C11\n",(0,s.jsx)(n.a,{href:"https://github.com/vnmakarov/mir",children:"with MIR JIT"}),".\nBut it's recommended to start using programming languages you are already familiar,\nlearning ",(0,s.jsx)(n.code,{children:"libriv"})," API plus a programming language might be too much to do at once."]}),"\n",(0,s.jsx)(n.h2,{id:"using-scripting-languages",children:"Using scripting languages"}),"\n",(0,s.jsxs)(n.p,{children:["In the last section we mentioned that RIV OS comes with Lua programming language,\nlet's try it.\nIn other to call functions from the C library ",(0,s.jsx)(n.code,{children:"libriv"}),",\nwe will use the ",(0,s.jsx)(n.a,{href:"https://github.com/q66/cffi-lua",children:"cffi-lua"})," to import and call C functions."]}),"\n",(0,s.jsxs)(n.p,{children:["First create the file ",(0,s.jsx)(n.code,{children:"hello.lua"})," to be used with LuaJIT:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:'#!/usr/bin/lua5.4\nlocal ffi = require \'cffi\'\nffi.cdef[[\ntypedef enum riv_color_id {\n  RIV_COLOR_BLACK       = 0,\n  RIV_COLOR_WHITE       = 1,\n} riv_color_id;\ntypedef enum riv_spritesheet_id {\n  RIV_SPRITESHEET_FONT_5X7 = 4095,\n} riv_spritesheet_id;\ntypedef enum riv_align {\n  RIV_CENTER = 4,\n} riv_align;\ntypedef struct riv_vec2i {int64_t x; int64_t y;} riv_vec2i;\nbool riv_present();\nvoid riv_clear(uint32_t col);\nriv_vec2i riv_draw_text(const char* text, uint64_t sps_id, riv_align anchor, int64_t x, int64_t y, int64_t size, int64_t col);\n]]\nlocal L = ffi.load("riv")\n\nrepeat\n  L.riv_clear(L.RIV_COLOR_BLACK)\n  L.riv_draw_text("hello world!", L.RIV_SPRITESHEET_FONT_5X7, L.RIV_CENTER, 128, 128, 2, L.RIV_COLOR_WHITE)\nuntil not L.riv_present()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice in this code the at the beginning we are manually importing ",(0,s.jsx)(n.code,{children:"libriv"})," APIs,\nat the bottom it's just again our hello example, lets run it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"chmod +x hello.lua\nrivemu -workspace -exec ./hello.lua\n"})}),"\n",(0,s.jsx)(n.p,{children:'And again, you will see the "hello world!" screen!'}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned before, Lua is contained the official RIV OS,\nbut interpreters for other programming languages are not.\nIf you would like to use Python or JavaScript for example,\nyou will have to embed their interpreter inside the cartridge which could make it very big,\nthis is it's recommended to use just official supported interpreted languages,\nor use interpreted languages small enough to embed in a cartridge.\nThere exists tiny versions for both Python and Javascript,\nthey are ",(0,s.jsx)(n.a,{href:"https://micropython.org/",children:"Micropython"})," and ",(0,s.jsx)(n.a,{href:"https://bellard.org/quickjs/",children:"QuickJS"}),",\nI would recommend embedding those inside cartridges instead,\nmaybe we could add official RIV support for them in the future."]}),"\n",(0,s.jsx)(n.p,{children:"If you have read this entire page, you have by now:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["run ",(0,s.jsx)(n.code,{children:"hello.c"})," using a ",(0,s.jsx)(n.code,{children:"riv-jit-c"})]}),"\n",(0,s.jsxs)(n.li,{children:["run ",(0,s.jsx)(n.code,{children:"hello.c"})," compiled with GCC compiler"]}),"\n",(0,s.jsxs)(n.li,{children:["run ",(0,s.jsx)(n.code,{children:"hello.c"})," compiled with GCC compiler with optimizations"]}),"\n",(0,s.jsxs)(n.li,{children:["run ",(0,s.jsx)(n.code,{children:"hello.nim"})," compiled with Nim compiler"]}),"\n",(0,s.jsxs)(n.li,{children:["run ",(0,s.jsx)(n.code,{children:"hello.lua"})," interpreted with Lua"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"It's recommended to use C for now,\nbut if you are adventurous,\nyou could use other languages as long as work out the bindings."}),"\n",(0,s.jsx)(n.h2,{id:"porting-other-games",children:"Porting other games"}),"\n",(0,s.jsxs)(n.p,{children:["You can port existing games to RIV, as long you have the code to compile it to RISC-V,\nhave all the tools you need in the SDK\nand the game works under all the constraints presented so far.\nPorting a game basically is a matter of changing the graphics, audio and input APIs\nto use ",(0,s.jsx)(n.code,{children:"libriv"})," C API."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/cartridge-freedoom",children:"DOOM cartridge repository"}),"\nrepository should serve as an example\non how a source code that was originally using the SDL library for handling\ngraphics/audio/input,\nwas ported to use the RIV library."]}),"\n",(0,s.jsx)(n.p,{children:"In the next chapter we will learn more details about the libriv API\nwhile creating a Snake game."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);