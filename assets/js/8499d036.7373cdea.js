"use strict";(self.webpackChunkrives_docs=self.webpackChunkrives_docs||[]).push([[5290],{3305:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var s=a(4848),t=a(8453);const i={sidebar_position:4},r="Creating a game",o={id:"riv/creating-a-game",title:"Creating a game",description:"This tutorial will guide on how to create a simple game and compile it into a cartridge.",source:"@site/docs/riv/creating-a-game.md",sourceDirName:"riv",slug:"/riv/creating-a-game",permalink:"/docs/riv/creating-a-game",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Developing cartridges",permalink:"/docs/riv/developing-cartridges"},next:{title:"Guides",permalink:"/docs/category/guides"}},d={},l=[{value:"Goals",id:"goals",level:2},{value:"Code for the game",id:"code-for-the-game",level:2},{value:"Setup project files",id:"setup-project-files",level:2},{value:"Drawing the title screen",id:"drawing-the-title-screen",level:2},{value:"Customizing the resolution and frame rate",id:"customizing-the-resolution-and-frame-rate",level:2},{value:"Starting the game",id:"starting-the-game",level:2},{value:"Spawning the apple",id:"spawning-the-apple",level:2},{value:"Moving the snake",id:"moving-the-snake",level:2},{value:"Growing the snake",id:"growing-the-snake",level:2},{value:"Adding sounds",id:"adding-sounds",level:2},{value:"Drawing sprites",id:"drawing-sprites",level:2},{value:"Adding scores",id:"adding-scores",level:2},{value:"Compiling the cartridge",id:"compiling-the-cartridge",level:2},{value:"Where to go now?",id:"where-to-go-now",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"creating-a-game",children:"Creating a game"}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will guide on how to create a simple game and compile it into a cartridge."}),"\n",(0,s.jsx)(n.p,{children:"For our first game we will choose the Snake game,\nbecause it's a very simple game."}),"\n",(0,s.jsx)(n.p,{children:"This tutorial will focus using the C programming language,\nand will assume you understand basic C,\nin the future it might be expanded to other languages."}),"\n",(0,s.jsx)(n.p,{children:"To make thing easier (and also performant!),\nthe C code is structured without use of pointers or memory allocations,\nso it should be easy to follow, even for people who know only basic C."}),"\n",(0,s.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,s.jsx)(n.p,{children:"At the end of this tutorial, you will have a working cartridge of the Snake game,\nready to be distributed or uploaded on RIVES."}),"\n",(0,s.jsx)(n.p,{children:"During this tutorial you will learn to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Draw rectangles on the screen"}),"\n",(0,s.jsx)(n.li,{children:"Draw sprites on the screen"}),"\n",(0,s.jsx)(n.li,{children:"Handle gamepad inputs"}),"\n",(0,s.jsx)(n.li,{children:"Play simple sounds"}),"\n",(0,s.jsx)(n.li,{children:"Compile a cartridge"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-for-the-game",children:"Code for the game"}),"\n",(0,s.jsxs)(n.p,{children:["If you are stuck, checkout the full source code for this tutorial at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/tree/main/demos/tutorial-snake",children:"demos/tutorial-snake folder"}),",\nevery chapter has its full source code there."]}),"\n",(0,s.jsx)(n.h2,{id:"setup-project-files",children:"Setup project files"}),"\n",(0,s.jsxs)(n.p,{children:["Before you begin you must have RIVEMU installed first, if you did not download it yet,\nplease read ",(0,s.jsx)(n.a,{href:"getting-started",children:"getting started page"})," first."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's begin creating a brand new directory called ",(0,s.jsx)(n.code,{children:"tutorial-snake"}),"\nwith the basic stuff you need there:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:'mkdir tutorial-snake\ncd tutorial-snake\necho "void main() {}" > snake.c\nrivemu -workspace -exec riv-jit-c snake.c\n'})}),"\n",(0,s.jsx)(n.p,{children:"The last line execute this simple C program, and you should see an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ rivemu -sdk -workspace -exec riv-jit-c snake.c\n[RIVEMU] Starting up...\n[RIVEMU] Open RIV device\n[RIVEMU] Close RIV device\n[RIVEMU] Cycles 58018349\n[RIVEMU] Shutting down...\n"})}),"\n",(0,s.jsx)(n.p,{children:"The C program did nothing interesting yet,\nit just opened and closed the RIV device,\nthe device responsible for handling graphics, audio and inputs."}),"\n",(0,s.jsx)(n.h2,{id:"drawing-the-title-screen",children:"Drawing the title screen"}),"\n",(0,s.jsxs)(n.p,{children:["Now open ",(0,s.jsx)(n.code,{children:"snake.c"})," in your favorite text editor,\nand add the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Header including all RIV APIs\n#include <riv.h>\n\n// Called every frame to draw the game\nvoid draw() {\n    // Clear screen\n    riv_clear(RIV_COLOR_DARKSLATE);\n    // Draw snake title\n    riv_draw_text(\n        "snake",                  // text to draw\n        RIV_SPRITESHEET_FONT_5X7, // sprite sheet id of the font\n        RIV_CENTER,               // anchor point on the text bounding box\n        128,                      // anchor x\n        128,                      // anchor y\n        4,                        // text size multiplier\n        RIV_COLOR_LIGHTGREEN      // text color\n    );\n}\n\n// Entry point\nint main() {\n    // Main loop, keep presenting frames until user quit or game ends\n    do {\n        // Draw game graphics\n        draw();\n    } while(riv_present());\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Save and run it with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"alias rivemu-jit-c='rivemu -sdk -workspace -no-loading -bench -exec riv-jit-c'\nrivemu-jit-c snake.c\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You should see the game's first title screen.\nNotice we added ",(0,s.jsx)(n.code,{children:"-no-loading"})," option here,\nthis will skip the loading screen, so we can test faster,\nthe other options are explained in\n",(0,s.jsx)(n.a,{href:"developing-cartridges",children:"developing cartridges page"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The code should be easy to understand so far,\nit just create the main game loop,\nand at every iteration it clears the screen and draws the game title."}),"\n",(0,s.jsx)(n.p,{children:"Notice we used some constant for colors and fonts,\nby default RIV comes with a predefined 32 color palette\nand two small predefined monospaced fonts,\nboth are customizable,\nhowever for this tutorial we will just use the default colors and fonts."}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-1.c",children:"snake-1.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-1.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"customizing-the-resolution-and-frame-rate",children:"Customizing the resolution and frame rate"}),"\n",(0,s.jsx)(n.p,{children:"By default RIV has a default resolution of 256x256\nand target frame rate of 60 frames per second,\nboth are customizable and can be changed at any time, even during the game main loop.\nWe will change the resolution down to 128x128 and target fps down o 8,\nas an exercise and because our snake game will be so simple\nthat drawing at a lower resolution and lower frame rate\ncan save us CPU overhead, and make game processing lighter.\nWell designed cartridges should try to use the minimal resolution and\nframe rate to save CPU resources."}),"\n",(0,s.jsx)(n.p,{children:"Let's update our code with the new resolution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Header including all RIV APIs\n#include <riv.h>\n\n// Called every frame to draw the game\nvoid draw() {\n    // Clear screen\n    riv_clear(RIV_COLOR_DARKSLATE);\n    // Draw snake title\n    riv_draw_text(\n        "snake",                  // text to draw\n        RIV_SPRITESHEET_FONT_5X7, // sprite sheet id of the font\n        RIV_CENTER,               // anchor point on the text bounding box\n        64,                       // anchor x\n        64,                       // anchor y\n        2,                        // text size multiplier\n        RIV_COLOR_LIGHTGREEN      // text color\n    );\n}\n\n// Entry point\nint main() {\n    // Set screen size and default frame rate\n    riv->width = 128;\n    riv->height = 128;\n    riv->target_fps = 8;\n    // Main loop, keep presenting frames until user quit or game ends\n    do {\n        // Draw game graphics\n        draw();\n    } while(riv_present());\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's run again, this is the last time in this tutorial we will paste\nthe command to run, next time we say \"run\" just execute the same command,\nlet's run it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"rivemu-jit-c snake.c\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It should just draw the exactly same title as before,\nbut now the computation is much lighter.\nIn fact if you compare this code version with the first code using the ",(0,s.jsx)(n.code,{children:"-bench"})," option\nyou will notice the overall rendering CPU cost is down from 2.90 MIPS to 0.12MIPS (96% decrease!).\nIf you want to learn more about the ",(0,s.jsx)(n.code,{children:"-bench"})," option, check ",(0,s.jsx)(n.a,{href:"developing-cartridges",children:"developing cartridges page"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-2.c",children:"snake-2.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-2.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"starting-the-game",children:"Starting the game"}),"\n",(0,s.jsx)(n.p,{children:"Ideally, every cartridge should have a start screen with a \"press to start\",\nmainly for two reasons. One because you don't know when the player loading\nscreen will finish, the performance may vary between systems the emulator is running on,\nand you don't want the game to start before the player's attention is on the screen.\nSecond because we will let RIV intentionally use the timing to press the button\nto feed entropy to its pseudo random number generator,\nso the apple on the snake game can start at random places despite\neverything being deterministic.\nLastly the start screen is a good opportunity to make a nice\nartwork with the game title and cover,\non RIVES the very first frame is used as the default cover for cartridges."}),"\n",(0,s.jsx)(n.p,{children:"Let's update our code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Header including all RIV APIs\n#include <riv.h>\n\n// Game state\nbool started; // true when game has started\nbool ended; // true when game has ended\n\n// Called when game starts\nvoid start_game() {\n    riv_printf("GAME START\\n");\n    started = true;\n}\n\n// Called when game ends\nvoid end_game() {\n    riv_printf("GAME OVER\\n");\n    ended = true;\n    // Quit in 3 seconds\n    riv->quit_frame = riv->frame + 3*riv->target_fps;\n}\n\n// Update game logic\nvoid update_game() {\n    // TODO: update game\n    end_game();\n}\n\n// Draw the game map\nvoid draw_game() {\n    // TODO: draw game\n}\n\n// Draw game start screen\nvoid draw_start_screen() {\n    // Draw snake title\n    riv_draw_text(\n        "snake",                  // text to draw\n        RIV_SPRITESHEET_FONT_5X7, // sprite sheet id of the font\n        RIV_CENTER,               // anchor point on the text bounding box\n        64,                       // anchor x\n        64,                       // anchor y\n        2,                        // text size multiplier\n        RIV_COLOR_LIGHTGREEN      // text color\n    );\n    // Make "press to start blink" by changing the color depending on the frame number\n    uint32_t col = (riv->frame % 2 == 0) ? RIV_COLOR_LIGHTRED : RIV_COLOR_DARKRED;\n    // Draw press to start\n    riv_draw_text("PRESS TO START", RIV_SPRITESHEET_FONT_5X7, RIV_CENTER, 64, 64+16, 1, col);\n}\n\n// Draw game over screen\nvoid draw_end_screen() {\n    // Draw last game frame\n    draw_game();\n    // Draw GAME OVER\n    riv_draw_text("GAME OVER", RIV_SPRITESHEET_FONT_5X7, RIV_CENTER, 64, 64, 2, RIV_COLOR_RED);\n}\n\n// Called every frame to update game state\nvoid update() {\n    if (!started) { // Game not started yet\n        // Let game start whenever a key has been pressed\n        if (riv->key_toggle_count > 0) {\n            start_game();\n        }\n    } else if (!ended) { // Game is progressing\n        update_game();\n    }\n}\n\n// Called every frame to draw the game\nvoid draw() {\n    // Clear screen\n    riv_clear(RIV_COLOR_DARKSLATE);\n    // Draw different screens depending on the game state\n    if (!started) { // Game not started yet\n        draw_start_screen();\n    } else if (!ended) { // Game is progressing\n        draw_game();\n    } else { // Game ended\n        draw_end_screen();\n    }\n}\n\n// Entry point\nint main() {\n    // Set screen size and default frame rate\n    riv->width = 128;\n    riv->height = 128;\n    riv->target_fps = 8;\n    // Main loop, keep presenting frames until user quit or game ends\n    do {\n        // Update game state\n        update();\n        // Draw game graphics\n        draw();\n    } while(riv_present());\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"A lot was done here:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We moved the title screen drawing into the ",(0,s.jsx)(n.code,{children:"draw_start_screen()"}),' method,\nand added code to draw a blinking "PRESS TO START".']}),"\n",(0,s.jsxs)(n.li,{children:["The code was refactored to have ",(0,s.jsx)(n.code,{children:"update()"})," and ",(0,s.jsx)(n.code,{children:"draw()"})," methods that behaves\ndifferently depending on the game state."]}),"\n",(0,s.jsx)(n.li,{children:"A GAME OVER screen was added, which should be triggered after pressing a key for now.\nWhen it is shown, the game quits after 3 seconds."}),"\n",(0,s.jsxs)(n.li,{children:["Some ",(0,s.jsx)(n.code,{children:"riv_printf"})," methods were added, just for debugging."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Most games will have base structure like this,\nwith this base structure set,\nwe can continue."}),"\n",(0,s.jsx)(n.p,{children:"Next chapters will apply patches on this base structure to evolve the game,\nso make sure you understand it before going on."}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-3.c",children:"snake-3.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-3.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"spawning-the-apple",children:"Spawning the apple"}),"\n",(0,s.jsx)(n.p,{children:"Let's spawn our first apple, and learn how to draw a rectangle in the process.\nFirst add an enum with some important game constants:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"enum {\n    MAP_SIZE = 16, // 16x16 tiles\n    TILE_SIZE = 8, // 8x8 pixels\n};\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Next, we can add a variable to store the state of our apple position:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"riv_vec2i apple_pos; // position of the current apple\n"})}),"\n",(0,s.jsx)(n.p,{children:"Next, we can add a method to respawn apples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Spawn apple in a new position\nbool respawn_apple() {\n    apple_pos = (riv_vec2i){riv_rand_uint(MAP_SIZE-1), riv_rand_uint(MAP_SIZE-1)};\n    return true;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice we are using RIV random functions here, the ",(0,s.jsx)(n.code,{children:"riv_rand_uint"}),",\ngames should always prefer to use RIV's random functions instead of the programming language random."]}),"\n",(0,s.jsxs)(n.p,{children:["We will call this method when the game starts, so add the following line at the end of ",(0,s.jsx)(n.code,{children:"start_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"respawn_apple();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Finally just draw it in ",(0,s.jsx)(n.code,{children:"draw_game()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void draw_game() {\n    // Draw apple\n    riv_draw_rect_fill(apple_pos.x*TILE_SIZE, apple_pos.y*TILE_SIZE, TILE_SIZE, TILE_SIZE, RIV_COLOR_LIGHTRED);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here we draw a 8x8 square at the apple position filled with light red color."}),"\n",(0,s.jsx)(n.p,{children:"Now run it multiple times, and notice every time we start the apple appears at random places\ndespite the game being deterministic.\nThat is because we took advantage of the starting screen timing and key inputs\nto seed the pseudo random number generator."}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-4.c",children:"snake-4.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-4.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"moving-the-snake",children:"Moving the snake"}),"\n",(0,s.jsx)(n.p,{children:"Let's add our snake and get it to move.\nTo make things simple, we will not let it grow yet,\nso the goal is to have a square moving on the screen while we can use it to catch apples,\nthis square will effectively be our snake head later."}),"\n",(0,s.jsx)(n.p,{children:"First add some new variables to the game state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int apples; // total amount of apples eaten\nriv_vec2i head_pos; // position of the snake head\nriv_vec2i head_dir; // direction of the snake head\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, we need to initialize those when the game starts inside ",(0,s.jsx)(n.code,{children:"start_game()"}),",\njust before ",(0,s.jsx)(n.code,{children:"respawn_apple()"})," call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"head_dir = (riv_vec2i){0, -1};\nhead_pos = (riv_vec2i){MAP_SIZE / 2, MAP_SIZE / 2};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now we can implement our ",(0,s.jsx)(n.code,{children:"update_game()"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'void update_game() {\n    // Set head direction based on inputs\n    if (riv->keys[RIV_GAMEPAD_UP].press) {\n        head_dir = (riv_vec2i){0, -1};\n    } else if (riv->keys[RIV_GAMEPAD_DOWN].press) {\n        head_dir = (riv_vec2i){0, 1};\n    } else if (riv->keys[RIV_GAMEPAD_LEFT].press) {\n        head_dir = (riv_vec2i){-1, 0};\n    } else if (riv->keys[RIV_GAMEPAD_RIGHT].press) {\n        head_dir = (riv_vec2i){1, 0};\n    }\n    // Move head\n    riv_vec2i next_head_pos = (riv_vec2i){head_pos.x + head_dir.x, head_pos.y + head_dir.y};\n    // Check if the head collides with the map boundary\n    if (next_head_pos.x < 0 || next_head_pos.y < 0 || next_head_pos.x >= MAP_SIZE || next_head_pos.y >= MAP_SIZE) {\n        end_game();\n    } else {\n        // Place the head on the body (will be overwritten later)\n        head_pos = next_head_pos;\n        // Check if the head collides with the apple\n        if (head_pos.x == apple_pos.x && head_pos.y == apple_pos.y) { // Apple was eaten\n            apples++;\n            riv_printf("APPLES %d\\n", apples);\n            if (!respawn_apple()) { // End game when cannot spawn more apples\n                end_game();\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Notice in the beginning we check ",(0,s.jsx)(n.code,{children:"pressed"})," state for gamepad buttons,\nthis boolean becomes true only in the frame the button was pressed.\nRIV emulates gamepads even with keyboards, but allows using them\nwhen a gamepad is plugged (such as PS4 Controller, XBOX or Nintendo Switch controller)."]}),"\n",(0,s.jsx)(n.p,{children:"Notice some logic was added to check if the head collides with map boundaries\nor it collides with an apple, when it collides with an apple we spawn a new apple."}),"\n",(0,s.jsxs)(n.p,{children:["Finally let's draw the snake head at the end of ",(0,s.jsx)(n.code,{children:"draw_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Draw snake head\nriv_draw_rect_fill(head_pos.x*TILE_SIZE, head_pos.y*TILE_SIZE, TILE_SIZE, TILE_SIZE, RIV_COLOR_LIGHTGREEN);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Run it, now you can move and catch apples!"}),"\n",(0,s.jsx)(n.p,{children:'Notice every time we collides with an apple the "APPLES" message is printed,\nand it respawns it in a new position.'}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-5.c",children:"snake-5.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-5.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"growing-the-snake",children:"Growing the snake"}),"\n",(0,s.jsx)(n.p,{children:"Now we need to get our snake to grow its body when it eats and apple,\nand move its body otherwise.\nIn order to do this we will need to keep track of its tail and head.\nThe idea to move is simple, just place its head in a new tile while removing its tail tile.\nIn order to keep track of the tail, we also need to store move direction for every tile in the body."}),"\n",(0,s.jsx)(n.p,{children:"First add some new game state variable:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"riv_vec2i tail_pos; // position of the snake tail\nriv_vec2i snake_body[MAP_SIZE][MAP_SIZE]; // move directions for the snake body\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, initialize them in ",(0,s.jsx)(n.code,{children:"game_start()"}),", before the call to ",(0,s.jsx)(n.code,{children:"respawn_apple()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"tail_pos = (riv_vec2i){head_pos.x - head_dir.x, head_pos.y - head_dir.y};\nsnake_body[head_pos.y][head_pos.x] = head_dir;\nsnake_body[tail_pos.y][tail_pos.x] = head_dir;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Next, add an utility function to check if a position collides with the snake body:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Check if position collides with snake body\nbool collides_with_body(riv_vec2i pos) {\n    return !(snake_body[pos.y][pos.x].x == 0 && snake_body[pos.y][pos.x].y == 0);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We have to rework or ",(0,s.jsx)(n.code,{children:"respawn_apple()"})," function to not let it spawn over the snake body:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"bool respawn_apple() {\n    // Returns false when there is not enough space to spawn more apples\n    if ((apples + 2) < (MAP_SIZE * MAP_SIZE)) {\n        do { // Try to spawn until there is no collision with its body\n            apple_pos = (riv_vec2i){riv_rand_uint(MAP_SIZE-1), riv_rand_uint(MAP_SIZE-1)};\n        } while (collides_with_body(apple_pos));\n        return true;\n    }\n    return false;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Out ",(0,s.jsx)(n.code,{children:"update_game()"})," will need some new lines, I will just paste it here:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'void update_game() {\n    // Set head direction based on inputs\n    if (riv->keys[RIV_GAMEPAD_UP].press) {\n        head_dir = (riv_vec2i){0, -1};\n    } else if (riv->keys[RIV_GAMEPAD_DOWN].press) {\n        head_dir = (riv_vec2i){0, 1};\n    } else if (riv->keys[RIV_GAMEPAD_LEFT].press) {\n        head_dir = (riv_vec2i){-1, 0};\n    } else if (riv->keys[RIV_GAMEPAD_RIGHT].press) {\n        head_dir = (riv_vec2i){1, 0};\n    }\n    // Save head move direction\n    snake_body[head_pos.y][head_pos.x] = head_dir;\n    // Move head\n    riv_vec2i next_head_pos = (riv_vec2i){head_pos.x + head_dir.x, head_pos.y + head_dir.y};\n    // Check if the head collides with the map boundary\n    if (next_head_pos.x < 0 || next_head_pos.y < 0 || next_head_pos.x >= MAP_SIZE || next_head_pos.y >= MAP_SIZE) {\n        end_game();\n    // Check if the head collides with its body\n    } else if (collides_with_body(next_head_pos)) {\n        end_game();\n    } else {\n        // Place the head on the body (will be overwritten later)\n        head_pos = next_head_pos;\n        snake_body[head_pos.y][head_pos.x] = head_dir;\n        // Check if the head collides with the apple\n        if (head_pos.x == apple_pos.x && head_pos.y == apple_pos.y) { // Apple was eaten\n            apples++;\n            riv_printf("APPLES %d\\n", apples);\n            if (!respawn_apple()) { // End game when cannot spawn more apples\n                end_game();\n            }\n        } else { // Apple was not eaten\n            // Remove tail\n            riv_vec2i tail_dir = snake_body[tail_pos.y][tail_pos.x];\n            snake_body[tail_pos.y][tail_pos.x] = (riv_vec2i){0,0};\n            // Update tail position\n            tail_pos = (riv_vec2i){tail_pos.x + tail_dir.x, tail_pos.y + tail_dir.y};\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The important additions were related to the snake body and the tail."}),"\n",(0,s.jsxs)(n.p,{children:["Finally, we need to replace the draw snake head code with a code to draw its body in ",(0,s.jsx)(n.code,{children:"draw_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"void draw_game() {\n    // Draw apple\n    riv_draw_rect_fill(apple_pos.x*TILE_SIZE, apple_pos.y*TILE_SIZE, TILE_SIZE, TILE_SIZE, RIV_COLOR_LIGHTRED);\n    // Draw snake body\n    for (int y = 0; y < MAP_SIZE; y++) {\n        for (int x = 0; x < MAP_SIZE; x++) {\n            if (collides_with_body((riv_vec2i){x,y})) {\n                riv_draw_rect_fill(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE, RIV_COLOR_LIGHTGREEN);\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Run it, now our snake grows!"}),"\n",(0,s.jsx)(n.p,{children:"The game logic is effectively finished.\nIn the next chapters we will focus on polishing it."}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-6.c",children:"snake-6.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-6.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"adding-sounds",children:"Adding sounds"}),"\n",(0,s.jsx)(n.p,{children:"The game has no sound yet, let's add it."}),"\n",(0,s.jsxs)(n.p,{children:["RIV comes with a simple level API for synthesizing sound waves using\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Envelope_(music)#ADSR",children:"ADSR envelope"}),"\non simple waveforms (such as square, triangular and sine waves),\nand you can play different tones by varying the waveform frequency.\nThis is how old school game consoles generated sounds."]}),"\n",(0,s.jsx)(n.p,{children:"Let's add on top of the file sound effect configs for start game, end game and eat apple:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Sound effects\nriv_waveform_desc start_sfx = {\n    .type = RIV_WAVEFORM_PULSE,\n    .attack = 0.01f, .decay = 0.01f, .sustain = 0.1f, .release = 0.01f,\n    .start_frequency = RIV_NOTE_A3, .end_frequency = RIV_NOTE_A4,\n    .amplitude = 0.25f, .sustain_level = 0.5f,\n};\nriv_waveform_desc end_sfx = {\n    .type = RIV_WAVEFORM_PULSE,\n    .attack = 0.01f, .decay = 0.01f, .sustain = 0.1f, .release = 0.01f,\n    .start_frequency = RIV_NOTE_A3, .end_frequency = RIV_NOTE_A2,\n    .amplitude = 0.5f, .sustain_level = 0.5f,\n};\nriv_waveform_desc eat_sfx = {\n    .type = RIV_WAVEFORM_PULSE,\n    .attack = 0.01f, .decay = 0.01f, .sustain = 0.1f, .release = 0.01f,\n    .start_frequency = RIV_NOTE_A4, .end_frequency = RIV_NOTE_A4,\n    .amplitude = 0.25f, .sustain_level = 0.5f,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here we choose pulse for chiptune style sounds.\nThe start sound has its wave frequency growing, giving the feeling that something will begin.\nThe end sound has its wave frequency decaying, giving the feeling that something will end.\nThe eat sound has its wave frequency steady, giving the feeling you got a point.\nYou can play with these values to synthesize different sound styles."}),"\n",(0,s.jsxs)(n.p,{children:["Now we just need to emit these sound effects at the right places.\nFirst in ",(0,s.jsx)(n.code,{children:"start_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Play start sound\nriv_waveform(&start_sfx);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next in ",(0,s.jsx)(n.code,{children:"end_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Play end sound\nriv_waveform(&end_sfx);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When an apple is eaten, inside ",(0,s.jsx)(n.code,{children:"update_game()"}),", just near the ",(0,s.jsx)(n.code,{children:"apples++"})," increment;"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Play eat sound\nriv_waveform(&eat_sfx);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Run it, now the game has sounds!"}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-7.c",children:"snake-7.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-7.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"drawing-sprites",children:"Drawing sprites"}),"\n",(0,s.jsx)(n.p,{children:"So far we have draw only solid squares,\nlet's upgrade our code to actually draw some sprites for the apple and snake head.\nFirst we will create a 16x16 image in the PNG format with 4 tiles of 8x8 pixels:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In the top left, the apple sprite, will have id 0"}),"\n",(0,s.jsx)(n.li,{children:"In the top right, left empty, will have id 1"}),"\n",(0,s.jsx)(n.li,{children:"In the bottom left, the snake head looking to the bottom, will have id 2"}),"\n",(0,s.jsx)(n.li,{children:"In the bottom right, the snake head looking to the right, will have id 3"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Use an image editor like GIMP or your favorite pixel art editor to do this,\nthen save it in ",(0,s.jsx)(n.code,{children:"sprites.png"})," file in the same folder as ",(0,s.jsx)(n.code,{children:"snake.c"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For the code changes, first we need to load this sprite file, add the following in the ",(0,s.jsx)(n.code,{children:"main()"}),"\nfunction before the main loop:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Load sprites\nriv_make_spritesheet(riv_make_image("sprites.png", 0), 8, 8);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This will load the image ",(0,s.jsx)(n.code,{children:"sprites.png"})," into a sprite sheet of 8x8 pixels of id ",(0,s.jsx)(n.code,{children:"1"}),".\nThe first sprite sheet loaded will always have its id set to ",(0,s.jsx)(n.code,{children:"1"}),", and the next ",(0,s.jsx)(n.code,{children:"2"}),", and so on.\nTo make our code clear, let's define this sprite sheet id in our constants enum:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"enum {\n    MAP_SIZE = 16, // 16x16 tiles\n    TILE_SIZE = 8, // 8x8 pixels\n    GAME_SPRITESHEET = 1,\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, to draw the apple and the snake, just replace its draw code in ",(0,s.jsx)(n.code,{children:"draw_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Draw apple\nriv_draw_sprite(0, GAME_SPRITESHEET, apple_pos.x*TILE_SIZE, apple_pos.y*TILE_SIZE, 1, 1, 1, 1);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Finally, add code to draw the snake head at the end of ",(0,s.jsx)(n.code,{children:"draw_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Draw snake face\nint spr_id = 2 + ((head_dir.x != 0) ? 1 : 0);\nint flip_x = (head_dir.x == -1) ? -1 : 1;\nint flip_y = (head_dir.y == -1) ? -1 : 1;\nriv_draw_sprite(spr_id, GAME_SPRITESHEET, head_pos.x*TILE_SIZE, head_pos.y*TILE_SIZE, 1, 1, flip_x, flip_y);\n"})}),"\n",(0,s.jsx)(n.p,{children:"We do some tricks here to choose the correct sprite and flip it depending on the head direction."}),"\n",(0,s.jsx)(n.p,{children:"Run it, now the game has more interesting visuals!"}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-8.c",children:"snake-8.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-8.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"adding-scores",children:"Adding scores"}),"\n",(0,s.jsxs)(n.p,{children:["To make this cartridge usable in RIVES in contests and achievements,\nyou have to output the game score every frame.\nWe do this by saving a JSON to the game ",(0,s.jsx)(n.em,{children:"outcard"})," every frame."]}),"\n",(0,s.jsx)(n.p,{children:"An interesting game score always take time into account,\nso people can challenge others on who is the fastest to accomplish something.\nRemembers also that RIV has a computation limit,\nso decreasing the game score as the game progresses can encourage people to play faster,\nand avoid this computation limit to be reached."}),"\n",(0,s.jsx)(n.p,{children:"We will create a score taking into account the amount of apples eaten while decreasing\nthe amount of game ticks (iterations or frames)."}),"\n",(0,s.jsx)(n.p,{children:"First create some new variables to keep track of the score:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int ticks; // total amount of game iterations\nint score; // game overall score\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next create a function to update the score, and save it to the ",(0,s.jsx)(n.em,{children:"outcard"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Output scores on the output card\nvoid update_scores() {\n    score = apples * MAP_SIZE * 2 - ticks;\n    riv->outcard_len = riv_snprintf((char*)riv->outcard, RIV_SIZE_OUTCARD, "JSON{\\"score\\":%d,\\"apples\\":%d,\\"ticks\\":%d}", score, apples, ticks);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here we save a table with interesting game statistics in JSON format,\nRIVES can use this table to create tournament using different formulas for the score.\nThis table should always have the ",(0,s.jsx)(n.code,{children:'"score"'})," field, this is the basic overall score for the game."]}),"\n",(0,s.jsxs)(n.p,{children:["Next, update the score every frame, by adding at the end of ",(0,s.jsx)(n.code,{children:"update()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// Output scores\nupdate_scores();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, we want to increment ",(0,s.jsx)(n.code,{children:"ticks"})," every ",(0,s.jsx)(n.code,{children:"update_game()"}),", so add to its begin:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"ticks++;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Finally, let's draw the overall score on the screen, add at the end of ",(0,s.jsx)(n.code,{children:"draw_game()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'// Draw score\nchar buf[128];\nriv_snprintf(buf, sizeof(buf), "SCORE %d", score);\nriv_draw_text(buf, RIV_SPRITESHEET_FONT_3X5, RIV_BOTTOMLEFT, 1, 128-1, 1, RIV_COLOR_WHITE);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Run it, now the game has scores!"}),"\n",(0,s.jsxs)(n.p,{children:["The source code for this chapter can be seen at\n",(0,s.jsx)(n.a,{href:"https://github.com/rives-io/riv/blob/main/demos/tutorial-snake/snake-9.c",children:"snake-9.c"}),"."]}),"\n",(0,s.jsx)("div",{align:"center",children:(0,s.jsx)("iframe",{src:"https://emulator.rives.io/#simple=true&cartridge=https://raw.githubusercontent.com/edubart/cartridges/main/snake-9.sqfs",allowFullScreen:!0,className:"rivemu-frame"})}),"\n",(0,s.jsx)(n.p,{children:"You can test above the cartridge for this chapter."}),"\n",(0,s.jsx)(n.h2,{id:"compiling-the-cartridge",children:"Compiling the cartridge"}),"\n",(0,s.jsxs)(n.p,{children:["Compiling a cartridge has been covered in the ",(0,s.jsx)(n.a,{href:"developing-cartridges",children:"developing cartridges guide"}),",\nread there for more details."]}),"\n",(0,s.jsx)(n.p,{children:"But in a short, having the SDK, you can compile the final snake cartridge and test it with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"alias rivemu-exec='rivemu -quiet -no-window -sdk -workspace -exec'\nrivemu-exec gcc snake.c -o snake '$(riv-opt-flags -Ospeed)'\nrivemu-exec riv-strip snake\nrivemu-exec riv-mksqfs snake sprites.png snake.sqfs\nrivemu snake.sqfs\n"})}),"\n",(0,s.jsx)(n.h2,{id:"where-to-go-now",children:"Where to go now?"}),"\n",(0,s.jsx)(n.p,{children:"You can continue and do more improvements in the snake, such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Improve the input handling. Right now if you release a key while another is being pressed, the snake will not move."}),"\n",(0,s.jsx)(n.li,{children:"Increase the snake speed as the game progresses, you could increase target fps while running for this."}),"\n",(0,s.jsx)(n.li,{children:"Tweak and add more sounds."}),"\n",(0,s.jsx)(n.li,{children:"Tweak and add more graphics."}),"\n",(0,s.jsx)(n.li,{children:"Make a more interesting score screen, with more statistics."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"After you finish your tweaking, you could try uploading it on RIVES."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var s=a(6540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);